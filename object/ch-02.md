# 2장 | 객체지향 프로그래밍

## 💻 자율적인 객체

- 객체를 자율적인 존재로 만들기 위해서는 외부의 간섭을 최소화해야 하며, 서로 메시지를 통해서만 상호작용해야 한다.
- 객체들은 서로 요청에 대해 스스로 최선의 방법으로 응답할 수 있을 것이라 믿고 메시지만 주고 받아야 한다.

### 클래스 구현하기

- 클래스의 경계를 명확하게 분리하는 것은 객체의 자율성을 보장하며, 프로그래머에게 구현의 자유를 제공한다.
- 외부에서 접근 가능한 퍼블릭 인터페이스와, 오직 내부에서만 접근 가능한 구현 부분을 명확히 분리해야 한다.

### 상속, 인터페이스, 다형성

- 상속을 통해 자식 클래스는 부모 클래스의 모든 인터페이스를 물려 받는다. 따라서 외부 객체는 자식 클래스를 부모 크래스와 동일한 타입으로 간주할 수 있다.
- 다형성은 동적 바인딩 메커니즘을 통해 실현된다. 실행 시점에 실제로 실행되는 메서드를 협력 객체의 실제 클래스가 무엇인지에 따라 선택적으로 연결하는 것이다.
- TEMPLATE METHOD 패턴: 부모 클래스에 기본적인 알고리즘을 구현하고, 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴


## 💻 추상화와 유연성

- 추상화를 통해 어플리케이션의 기본적인 협력 흐름을 서술할 수 있다. 세부적인 내용을 무시하고 쉽고 간단하게 상위 수준에서 서술할 수 있는 것이다.
- 추상화를 통해 일관성을 유지할 수 있으며, 설계가 구체적인 상황에 결합되는 것을 방지할 수 있다.
- 단, 항상 유연한 설계만이 정답은 아니라는 것을 염두에 두어야 한다. 유연한 설계는 그만큼 이해하기 어렵기 때문이다.
- 따라서, 모든 코드는 트레이드오프를 고려하여 합당한 이유를 근거를 바탕으로 작성해야 한다.

### 상속과 합성

- 상속은 부모와 자식 클래스를 하나의 단위로 강하게 결합하며, 캡슐화를 위반하고 유연하지 못한 설계를 만든다.
- 합성은 인터페이스를 통해 약하게 결합되며, 서로 내부 구현에 대해 전혀 알지 못한다.
- 따라서, 불가피한 경우를 제외하고는 코드의 유연성과 재사용성 면에서 상속보다는 합성이 더 바람직하다.
